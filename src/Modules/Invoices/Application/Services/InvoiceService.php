<?php

declare(strict_types=1);

namespace Modules\Invoices\Application\Services;

use Exception;
use Ramsey\Uuid\Uuid;
use Modules\Invoices\Domain\Enums\StatusEnum;
use Modules\Invoices\Domain\Models\Invoice;
use Modules\Invoices\Domain\Models\InvoiceProductLine;
use Modules\Invoices\Domain\Repositories\InvoiceRepositoryInterface;
use Modules\Notifications\Api\Dtos\NotifyData;
use Modules\Notifications\Api\NotificationFacadeInterface;

class InvoiceService
{
    public function __construct(
        private InvoiceRepositoryInterface $invoiceRepository,
        private NotificationFacadeInterface $notificationFacade
    ) {}

    public function createInvoice(array $data): Invoice
    {
        $invoice = new Invoice([
            'customer_name' => $data['customer_name'],
            'customer_email' => $data['customer_email'],
            'status' => StatusEnum::Draft, // Requirement: Created in draft
        ]);

        // We need to save the invoice first to generate an ID (if not auto-generated by model boot)
        // But HasUuids trait usually handles it on creation.
        // However, we need to attach lines.
        
        $lines = [];
        foreach ($data['product_lines'] ?? [] as $lineData) {
            $lines[] = new InvoiceProductLine([
                'name' => $lineData['name'],
                'quantity' => $lineData['quantity'],
                'price' => $lineData['price'],
            ]);
        }

        // We'll assign the lines to the invoice.
        // Since we are using push() in repo, we can associate them in memory.
        $invoice->setRelation('productLines', collect($lines));
        
        // Note: setRelation alone doesn't set the foreign key on the child objects for saving.
        // We need to manually loop or save the invoice first.
        // To keep it atomic, let's save the invoice, then saveLines.
        // Or relies on the repo implementation.
        // Given the Repo 'save' uses 'push', we need the parent to exist or at least be connected.
        
        // Let's refine:
        $this->invoiceRepository->save($invoice);
        
        // Now save lines with the relationship
        $invoice->productLines()->saveMany($lines);

        return $invoice;
    }

    public function getInvoice(string $id): ?Invoice
    {
        return $this->invoiceRepository->find($id);
    }

    /**
     * @throws Exception
     */
    public function sendInvoice(string $id): void
    {
        $invoice = $this->invoiceRepository->find($id);

        if (!$invoice) {
            throw new Exception("Invoice not found");
        }

        // Requirement: Can only send if draft
        if ($invoice->status !== StatusEnum::Draft) {
            throw new Exception("Invoice must be in draft status to be sent");
        }

        // Requirement: Must contain product lines
        if ($invoice->productLines->isEmpty()) {
            throw new Exception("Invoice must have product lines to be sent");
        }

        // Requirement: Positive integers > 0
        // Note: Casts enforce integer, we just need to check > 0
        foreach ($invoice->productLines as $line) {
            if ($line->quantity <= 0 || $line->price <= 0) {
                throw new Exception("All product lines must have positive quantity and price");
            }
        }

        // Send Notification
        $this->notificationFacade->notify(new NotifyData(
            resourceId: Uuid::fromString($invoice->id),
            toEmail: $invoice->customer_email,
            subject: "Invoice for " . $invoice->customer_name,
            message: "Please find your invoice attached."
        ));

        // Requirement: Change status to sending
        $invoice->status = StatusEnum::Sending;
        $this->invoiceRepository->save($invoice);
    }
}

